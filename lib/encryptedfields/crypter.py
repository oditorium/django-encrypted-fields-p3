"""
Simple wrapper object for the PyCrypto Library

COPYRIGHT

Copyright (c) Stefan LOESCH, oditorium 2016. All rights reserved.
Licensed under the Mozilla Public License, v. 2.0 <https://mozilla.org/MPL/2.0/>
"""
__version__ = "2.1"
__version_dt__ = "2015-05-30"

from Crypto.Cipher import AES
from Crypto import Random
from hashlib import sha256
from zlib import compress, decompress


#################################################################################################
## CRYPTER
class CrypterError(RuntimeError): pass
class CrypterInvalidKeyError(CrypterError): pass
class CrypterWrongVersionError(CrypterError): pass
class CrypterWrongFormatError(CrypterError): pass
class CrypterDecryptionError(CrypterError): pass

class Crypter():
    """
    string encryption and decryption

    USAGE
    
    Standard usage of this class is as follows 
    
        c = Crypter("my secret key - should have 32 bytes entropy")
        ciphert = c.Encrypt("plaintext")
        ...
        c = Crypter("my secret key - should have 32 bytes entropy")
        c.Decrypt(ciphert)
        
    Instead of a key string, the key can also be provided directly (eg generated by Crypter)
    
        my_key = Crypter.random_key()
        c = Crypter(my_key)
        ...
        
    A derived class can also define keys by overwriting _SECRET_KEY
    
        class MyCrypter(Crypter):
            _SECRET_KEY = Crypter.key_from_str("my super secret key")

    NOTES
    - Encrypt accepts both string and bytes arguments; Decrypt preserves this, ie an encrypted string
        is returned as string, and encrypted bytes are returned as bytes
    - the `secret_key` argument of the constructor should ideally be a string with at least 32 bytes
        of entropy which is converted into an AES key; alternatively a raw key can be provided, in 
        which case it must be a 32 byte bytes object
    """
    BLOCK_SIZE = 32
    IV_SIZE = 16
    _SECRET_KEY = None      # defauly secret key or key string (can be overwritten in derived class)
    default_secret_key = classmethod(lambda cls: cls._SECRET_KEY)

    
    VERSION = b'\x21'       # version number (\x21 = 2.1) 
    FILLER  = b'\x00' * 3   # filler

    INTERRUPT = u'\u0001'   # only used for _add_padding_alt, _strip_padding_alt
    PAD       = u'\u0000'   # (those functions are not currently in use)

    compress = True         # whether to compress (can be overridden in constructor, or by derived class) 


    #############################################################
    ## INIT
    def __init__(s, secret_key=None, compress=None):
        
        # if not secret key is given, first try the one from the class...
        if not secret_key: secret_key = s._SECRET_KEY
        
        # ...and if this does not work generate a random key
        if not secret_key: secret_key = s.random_key()
        
        # if the key is a string (as oppose to bytes) convert it
        if isinstance(secret_key, str): secret_key = s.key_from_str(secret_key)
        
        # set the instance variable
        if not isinstance(secret_key, bytes): raise CrypterInvalidKeyError("secret_key must be either str or bytes")
        if not len(secret_key) == 32: raise CrypterInvalidKeyError("raw keys must be of exactly 32 bytes length")
        s.secret_key = secret_key

        # set compress flag
        if not compress == None: s.compress = compress
        
    
    
    #############################################################
    ## PADDING
    def _add_padding(s, plaintext):
        """add padding to plaintext before encryption"""
        padlen = (s.BLOCK_SIZE - len(plaintext)) % s.BLOCK_SIZE
        return plaintext + (chr(padlen).encode())*padlen, padlen
    
    def _strip_padding(s, plaintext, padlen):
        """remove padding from decrypted ciphertext"""
        if padlen == 0: return plaintext
        return plaintext[:-padlen]


    # def _add_padding_alt2(s, plaintext):
    #     """add padding to plaintext before encryption"""
    #     padlen = (s.BLOCK_SIZE - len(plaintext)) % s.BLOCK_SIZE
    #     return plaintext + (chr(padlen).encode())*padlen
    # 
    # def _strip_padding_alt2(s, plaintext):
    #     """remove padding from decrypted ciphertext"""
    #     return plaintext[:-ord(plaintext[len(plaintext)-1:])]
    # 
    # def _add_padding_alt(s, plaintext):
    #     """add padding to plaintext before encryption (alternative)"""
    #     plaintext = plaintext+s.INTERRUPT
    #     pad_string = s.PAD * ( (s.BLOCK_SIZE - len(plaintext)) % s.BLOCK_SIZE)
    #     return plaintext+pad_string.encode()
    # 
    # def _strip_padding_alt(s, plaintext):
    #     """remove padding from decrypted ciphertext (alternative)"""
    #     return plaintext.rstrip(s.PAD).rstrip(s.INTERRUPT)
    

    #############################################################
    ## ASSEMBLE and DISASSEMBLE
    def _assemble(s, ciphertext, iv, as_bytes, compressed, padlen):
        """assemble ciphertext with iv and some header info"""
        as_bytes = b'\xff' if as_bytes else b'\x00'
        compressed = b'\xff' if compressed else b'\x00'
        return s.VERSION + as_bytes + compressed + bytes([padlen]) + s.FILLER + iv + ciphertext
    
    def _disassemble(s, assembled_ciphertext):
        """separate iv and header information from ciphertext"""
        l = len(s.FILLER)
        li = l + s.IV_SIZE
        try:
            result =  {
                'version'     : assembled_ciphertext[0:1],
                'as_bytes'    : True if assembled_ciphertext[1] else False,
                'compressed'  : True if assembled_ciphertext[2] else False,
                'padlen'      : assembled_ciphertext[3],
                'filler'      : assembled_ciphertext[4:l+4],
                'iv'          : assembled_ciphertext[l+4:li+4],
                'ciphertext'  : assembled_ciphertext[li+4:]
            }
        except: 
            #raise
            raise CrypterWrongFormatError(assembled_ciphertext)
        return result


    #############################################################
    ## DECRYPT
    def Decrypt(s, assembled_ciphertext, decoder=None):
        """
        decrypt a ciphertext obtained by Encrypt (into string or bytes, depending on initial format)
        """
        if not assembled_ciphertext: return assembled_ciphertext # deals with '' or None
        assembled_ciphertext = decoder(assembled_ciphertext) if decoder else assembled_ciphertext
        #print ("ciphertext1:{}".format(assembled_ciphertext))
        ct = s._disassemble(assembled_ciphertext)
        #print ("ciphertext2:{}".format(ct['ciphertext']))
        if ct['version'] != s.VERSION: raise CrypterWrongVersionError()
        #print (ct['ciphertext'])
        decrypter = AES.new(s.secret_key, AES.MODE_CBC, ct['iv'])
        try: plaintext = decrypter.decrypt(ct['ciphertext'])
        except: raise CrypterDecryptionError()
        #print ("plaintext1:{}".format(plaintext))
        plaintext = s._strip_padding(plaintext, ct['padlen'])
        #print ("plaintext2:{}".format(plaintext))
        if ct['compressed']: plaintext = decompress(plaintext)
        #print ("plaintext3:{}".format(plaintext))
        if not ct['as_bytes']: plaintext = plaintext.decode()
        #print ("plaintext4:{}".format(plaintext))
        return plaintext


    #############################################################
    ## ENCRYPT
    def Encrypt(s, plaintext, encoder=None):
        """
        encrypt a plaintext (string or bytes; decrypt preserves this)
        """
        iv = Random.new().read(s.IV_SIZE)
        encrypter = AES.new(s.secret_key, AES.MODE_CBC, iv)
        as_bytes = isinstance(plaintext, bytes)
        #print ("plaintext1:{}".format(plaintext))
        if not as_bytes: plaintext = plaintext.encode()
        #print ("plaintext2:{}".format(plaintext))
            # if we get a string we need to encode it (no need to encode bytes...)
        if s.compress: plaintext = compress(plaintext)
        #print ("plaintext3:{}".format(plaintext))
        plaintext, padlen = s._add_padding(plaintext)
        ciphertext = encrypter.encrypt(plaintext)
        #print ("ciphertext1:{}".format(ciphertext))
        #print (ciphertext)
        ciphertext = s._assemble(ciphertext, iv, as_bytes, s.compress, padlen)
        #print ("ciphertext2:{}".format(ciphertext))
        return encoder(ciphertext) if encoder else ciphertext


    #############################################################
    ## KEY MANAGEMENT
    random_key = classmethod(lambda cls: Random.new().read(cls.BLOCK_SIZE))                 # generates a random key
    key_from_str = classmethod(lambda cls, key_s: sha256( key_s.encode() ).digest())        # generates key from string

# import lib.encryptedfields.crypter as cr
# c = cr.Crypter("my secret pw")
# print (c.secret_key)
# plaint = "Test123Test"
# ciphert = c.Encrypt(plaint)
# print (ciphert)
# plaint2 = c.Decrypt(ciphert)
# print (plaint2)
# 
# import lib.encryptedfields.crypter as cr
# c = cr.Crypter("my secret pw")
# plaint = "Test"
# ciphert = c.Encrypt(plaint)
# print (ciphert)
# plaint2 = c.Decrypt(ciphert)
# print (plaint2)
# 
# import lib.encryptedfields.crypter as cr
# c = cr.Crypter("my secret pw")
# plaint = b"Test"
# ciphert = c.Encrypt(plaint)
# print (ciphert)
# plaint2 = c.Decrypt(ciphert)
# print (plaint2)
